// AUTHOR: Konstantin Ottnad
//
// DATE: 20131212
//
// Implements:
// - reader for binary files including possible headers (e.g. as generated by threep-block.c)
// - parsers for (various) header types
// - basic routines for data conversion (e.g. converters for endianess)
// - reader for numerical tables in plain text files (gsl based)
#ifndef io_hh
#define io_hh

#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stdint.h>
#include <stdlib.h>
#include <gsl/gsl.h>
#include <gsl/gsl_linalg.h>


using namespace std;

const unsigned int littleEndian = 0;
const unsigned int bigEndian = 1;
const string format_2pt_meson   = "iiiiddsss";
const string format_2pt_nucleon = "iiiiddddddddss";
const string format_2pt_nucleon_projected = "iiiidd"; // 0th-order tensor
const string format_3pt_nucleon_order0 = "iiiidd";    // 0th-order tensor
const string format_3pt_nucleon_order1 = "iiiiddi";   // 1st-order tensor 
const string format_3pt_nucleon_order2 = "iiiiddii";  // 2nd-order tensor
const string format_3pt_nucleon_order3 = "iiiiddiii"; // 3rd-order tensor
const string format_momenta = "iii";


unsigned int get_endianess();                               // determine machine endianess
void swap_byte_order_4(char *block, int64_t block_length);  // swap endianess of data block consisting of four-byte words
void swap_byte_order_8(char *block, int64_t block_length);  // swap endianess of data block consisting of eight-byte words
int write_mixed_text(const string filename, const string format, const double *data, const int *index, const string *label, const unsigned int no_lines, const unsigned int append); // writes a file that can be parsed by a mixed_text_reader object; for description of the format string see class implementation. Dimensions of the three input arrays are determined implicitly from 'format'-string and 'no_lines'.



class binary_reader
{
  private:
    string filename;
    string start_header, end_header;
    string *header;
    ifstream stream;
    unsigned int error;
    int header_lines;
    int header_bytes;
    int get_header_size();

  public:
    char *data;                         // data has to be public (e.g. issues with endianess for some data types, fast routines ...)
    binary_reader(string fname, string shead, string ehead);
    ~binary_reader();
    string get_error();                 // returns the current error status
    int read_header();                  // reads the header into 'header' and return the number of lines
    int64_t read_data();                // reads the binary part of the file an returns the number of bytes
    string get_filename();              // returns the filename
    string parse_header(string tag);    // search for first occurrence of a string in the header, return the remainder of the line and delete it from 'header' 
    void print_header(ostream *stream); // prints the header to a stream, avoiding empty lines
};


class text_reader  // base class for text file readers and for general text files
{
  protected:
    string filename;
    unsigned int columns;
    unsigned int lines;
    unsigned int error;
    unsigned int start_skip;
    unsigned int end_skip;

  public:
    ifstream stream;
    unsigned int get_columns();
    unsigned int get_lines();
    unsigned int get_error_id();
    virtual string get_error();
    text_reader(string fname, unsigned int sskip, unsigned int eskip); // '?skip' determines number of lines to be skipped at start and end of file
    virtual ~text_reader();
};


class numeric_text_reader: public text_reader // reads numerical data (tables) from text files
{
  private:
    FILE * file; // gsl does not use streams

  public:
    gsl_matrix *data;
    numeric_text_reader(string fname);
    virtual ~numeric_text_reader();
};


class mixed_text_reader: public text_reader // Class to read various mixed (numbers + strings) text file formats.
{
  private:
    unsigned int no_int, no_double, no_string; // these are determined during initialization from format string
  public:
    double *data;      // array for numeric data
    int *index;        // array for (integer) indices (e.g. t, momenta)
    string *label;     // array for labels (e.g. spin structure, smearing)
    mixed_text_reader(string fname, unsigned int sskip, unsigned int eskip, string format); // format determines the data types of the columns: 'd': double,'i': int, 's': string
    virtual ~mixed_text_reader();
    int find_index(unsigned int column, int skip, const int value); // finds 'value' in 'index' starting at 'skip', Returns -1 if not found, or if skip<0 
    int find_index_vector(int skip, const int values[]); // finds a vector ('values') in 'index' starting at 'skip', Returns -1 if not found, or if skip<0
    int get_index_max_value(unsigned int column); // returns the max value of a index given 'column' in the 'index' array. Required stride is determined from format string
    int get_index_min_value(unsigned int column);
    unsigned int get_no_double();
    unsigned int get_no_int();
    unsigned int get_no_string();
};

#endif
